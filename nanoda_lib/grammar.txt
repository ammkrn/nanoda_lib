exportFile ::= traceLine\n*

-- The bang will show up once per file, after the initial set
-- of items that are supposed to be in-scope for the whole file
-- has finished, which we'll call 'universal' items, since 'environment'
-- is sort of overloaded with Gamma.

-- A line with just '%' will be printed after every new declaration
-- is checked and admitted, the significance of that to a verifier
-- being that this is also when the local context which extendeds
-- the initial set of universal items is dropped, and we go back to only
-- considering elements that were declared before the `!`.

-- The only thing that needs to "carry over" between local contexts
-- are any `AdmitDeclar` steps since that's how we build up the environment.
-- Step numbers are monotonically increasing
-- even across local contexts, so any step number in a later local block
-- is guaranteed to be higher than any step number in previous blocks,
-- but local item numbers reset to 0, which shouldn't be an issue
-- since there are no cases in which items need to be considered
-- across local contexts.

traceLine ::= 
    | item
    | step
    | '!'
    | '%'

nat ::= 0-9*
alphaNum ::= a-zA-Z0-9

// misc terminals.
binderStyle ::= 'd' | 'i' | 's' | 'c'
reducibilityHint ::= 'o' | 'a' | nat
inferFlag ::= 'I' | 'C'
bool ::= 't' | 'f'
eqResult ::= 'EQ'
deltaResult ::= eqResult | exprRef '.' exprRef


item ::= 
    | stringItem 
    | name 
    | level 
    | expr 
    | recRule 
    | declar 
    | declarView
    | nameList 
    | levelList 
    | exprList 
    | recRuleList 
    | declarList
    | indBlock
    | checkedIndBlockRef

itemRef ::= 
    | stringRef 
    | nameRef 
    | levelRef 
    | exprRef 
    | recRuleRef 
    | declarRef
    | declarViewRef
    | indBlockRef
    | checkedIndBlockRef

-- options are only either itemRefs or nats.
optionNat ::= 
    | 'S' nat
    | 'N'

optionItemRef ::=
    | 'S' itemRef
    | 'N'


stringRef ::= itemLoc nat 's'
stringItem ::= itemLoc 's' '.' alphaNum*

nameRef ::= itemLoc nat 'n'
nameList ::= 
    | listLoc nat 'n_'
    | listLoc nat 'n.' nameRef '.' listLoc nat 'n'

name ::= 
    | itemLoc nat 'na' 
    | itemLoc nat 'ns' '.' nameRef '.' stringRef
    | itemLoc nat 'ni' '.' nameRef '.' nat



levelRef ::= itemLoc nat 'u'
levelList ::= 
    | listLoc nat 'u_' 
    | listLoc nat 'u.' levelRef '.' listLoc nat 'u'

level ::=
    | itemLoc nat 'uz'
    | itemLoc nat 'us' '.' levelRef
    | itemLoc nat 'um' '.' levelRef '.' levelRef
    | itemLoc nat 'ui' '.' levelRef '.' levelRef
    | itemLoc nat 'up' '.' nameRef


exprRef ::= itemLoc nat 'e'
exprList ::= 
    | listLoc nat 'e_' 
    | listLoc nat 'e.' exprRef '.' listLoc nat 'e'

expr ::=  
    | itemLoc nat 'ev' 0-9*
    | itemLoc nat 'es' '.' levelRef
    | itemLoc nat 'ec' '.' nameRef '.' itemListRef
    | itemLoc nat 'ea' '.' exprRef '.' exprRef
    | itemLoc nat 'ep' '.' nameRef '.' exprRef '.' binderStyle '.' exprRef
    | itemLoc nat 'el' '.' nameRef '.' exprRef '.' binderStyle '.' exprRef
    | itemLoc nat 'ez' '.' nameRef '.' exprRef '.' binderStyle '.' exprRef '.' exprRef
    | itemLoc nat 'ex' '.' nameRef '.' exprRef '.' binderStyle '.' nat

recRuleRef ::= itemLoc nat 'r'
recRuleList ::= 
    | listLoc nat 'r_' 
    | listLoc nat 'r.' recRuleRef '.' listLoc nat 'r'

recRule ::= itemLoc nat 'r' '.' nameRef '.' nat '.' exprRef

declarRef ::= itemLoc nat 'd'
declarList ::=
    | listLoc nat 'd_'
    | listLoc nat 'd.' declarRef '.' listLoc nat 'd'


-- 'theorem' and 'opaque' ('dt' and 'do') are not yet used by lean3 export files; 
-- they're kernel items in lean4 that may or may not be present in lean4 exports
declar ::= 
    | itemLoc nat 'da' '.' nameRef '.' itemListRef '.' exprRef '.' bool
    | itemLoc nat 'dd' '.' nameRef '.' itemListRef '.' exprRef '.' exprRef '.' reducibilityHint '.' bool
    | itemLoc nat 'dq' '.' nameRef '.' itemListRef '.' exprRef
    | itemLoc nat 'di' '.' nameRef '.' itemListRef '.' exprRef '.' nat '.' itemListRef '.' itemListRef
    | itemLoc nat 'dc' '.' nameRef '.' itemListRef '.' exprRef '.' nameRef '.' { 3 * nat '.' } bool
    | itemLoc nat 'dr' '.' nameRef '.' itemListRef '.' exprRef '.' itemListRef '.' { 5 * nat '.' } itemListRef '.' bool '.' bool
    | itemLoc nat 'dt' '.' nameRef '.' itemListRef '.' exprRef '.' exprRef
    | itemLoc nat 'do' '.' nameRef '.' itemListRef '.' exprRef '.' exprRef '.' bool


-- name, upsarams, type, option val
declarView ::= itemLoc nat 'v' '.' nameRef '.' itemListRef '.' exprRef '.' optionItemRef
declarViewRef ::= itemLoc nat 'v'

-- is_unsafe, num_params, uparams, ind_names, ind_types, ctor_names, ctor_types
indBlock ::= 'ib' nat '.' bool '.' nat '.' { 5 * itemListRef '.' }
indBlockRef ::= 'ib' nat

-- indblock ++ codom_level, use_dep_elim, is_zero, is_nonzero, params, indices, ind_consts
checkedIndBlock ::= 'cb' nat '.' bool '.' nat '.' { 5 * itemListRef '.' } levelRef '.' bool '.' bool '.' { 3 * itemListRef '.' }
checkedIndBlockRef ::=  'cb' nat

/*
There's a machine-generated file at ./step_grammar.txt that has a more detailed
breakdown that dictates exactly how to parse each step so you have more options
on how you want to write the parser, IE whether you want to use a general rule,
or whether you want to have a more detailed/safe parser with specific rules
for each different step.

I tried to make the elements of each step match the order in which they appear
in the lean spec, but since I think the spec might change wrt field projections
and maybe some other things, I didn't agonize over it, and can't guarantee I haven't messed up. 
I can say for sure that each step's children will appear (from left to right) 
in the order in which they appear from top to bottom as fields in their corresponding 
enum variant (they're all in trace::steps), so I would use that as a reference for now.

The only case in which a pointer to a child step/hypothesis 
is an optionNat is for AdmitDeclar steps, since the first
declaration will not have anything to point to.
*/

stepDiscrim ::= A-Z*
stepCtor ::= A-Z
step ::= nat '.' stepDiscrim '.' stepCtor '.' child*
stepRef ::= nat

child ::=  '.' childItem

childItem ::= 
    | nat
    | itemRef
    | optionItemRef
    | optionNat
    | '(' childItem . childItem ')'
    | '(' childItem . childItem . childItem ')'
    | bool
    | eqResult
    | binderStyle
    | reducibilityHint
    | inferFlag
    | deltaResult



