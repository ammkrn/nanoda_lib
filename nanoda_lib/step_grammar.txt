PosBaseNone ::= nat '.' LP '.' N '.' { 3 * child }
PosBaseSome ::= nat '.' LP '.' O '.' { 4 * child }
PosStep ::= nat '.' LP '.' S '.' { 7 * child }
IsSubsetBaseNil ::= nat '.' SS '.' N '.' { 3 * child }
IsSubsetStep ::= nat '.' SS '.' S '.' { 9 * child }
NoDupesBaseNil ::= nat '.' ND '.' N '.' { 2 * child }
NoDupesStepTt ::= nat '.' ND '.' S '.' { 6 * child }
GetPrefixBaseAnon ::= nat '.' GP '.' A '.' { 2 * child }
GetPrefixStepStr ::= nat '.' GP '.' S '.' { 3 * child }
GetPrefixStepNum ::= nat '.' GP '.' N '.' { 3 * child }
IsParamZero ::= nat '.' IP '.' Z '.' { 2 * child }
IsParamSucc ::= nat '.' IP '.' S '.' { 3 * child }
IsParamMax ::= nat '.' IP '.' M '.' { 4 * child }
IsParamImax ::= nat '.' IP '.' I '.' { 4 * child }
IsParamParam ::= nat '.' IP '.' P '.' { 3 * child }
IsZeroLitZero ::= nat '.' ZL '.' Z '.' { 2 * child }
IsZeroLitSucc ::= nat '.' ZL '.' S '.' { 3 * child }
IsZeroLitMax ::= nat '.' ZL '.' M '.' { 4 * child }
IsZeroLitImax ::= nat '.' ZL '.' I '.' { 4 * child }
IsZeroLitParam ::= nat '.' ZL '.' P '.' { 3 * child }
IsSuccZero ::= nat '.' NS '.' Z '.' { 2 * child }
IsSuccSucc ::= nat '.' NS '.' S '.' { 3 * child }
IsSuccMax ::= nat '.' NS '.' M '.' { 4 * child }
IsSuccImax ::= nat '.' NS '.' I '.' { 4 * child }
IsSuccParam ::= nat '.' NS '.' P '.' { 3 * child }
IsAnyMaxZero ::= nat '.' AM '.' Z '.' { 2 * child }
IsAnyMaxSucc ::= nat '.' AM '.' S '.' { 3 * child }
IsAnyMaxMax ::= nat '.' AM '.' M '.' { 4 * child }
IsAnyMaxImax ::= nat '.' AM '.' I '.' { 4 * child }
IsAnyMaxParam ::= nat '.' AM '.' P '.' { 3 * child }
CombiningLzero ::= nat '.' CO '.' L '.' { 3 * child }
CombiningRzero ::= nat '.' CO '.' R '.' { 3 * child }
CombiningSucc ::= nat '.' CO '.' S '.' { 7 * child }
CombiningOwise ::= nat '.' CO '.' O '.' { 7 * child }
SimplifyZero ::= nat '.' SI '.' Z '.' { 2 * child }
SimplifyParam ::= nat '.' SI '.' P '.' { 3 * child }
SimplifySucc ::= nat '.' SI '.' S '.' { 5 * child }
SimplifyMax ::= nat '.' SI '.' M '.' { 9 * child }
SimplifyImaxZero ::= nat '.' SI '.' IZ '.' { 6 * child }
SimplifyImaxSucc ::= nat '.' SI '.' IS '.' { 10 * child }
SimplifyImaxOwise ::= nat '.' SI '.' IO '.' { 10 * child }
ParamsDefinedZero ::= nat '.' PD '.' Z '.' { 3 * child }
ParamsDefinedSucc ::= nat '.' PD '.' S '.' { 5 * child }
ParamsDefinedMax ::= nat '.' PD '.' M '.' { 7 * child }
ParamsDefinedImax ::= nat '.' PD '.' I '.' { 7 * child }
ParamsDefinedBaseParam ::= nat '.' PD '.' Q '.' { 5 * child }
ParamsDefinedStepParam ::= nat '.' PD '.' R '.' { 7 * child }
SubstLZero ::= nat '.' SL '.' Z '.' { 4 * child }
SubstLSucc ::= nat '.' SL '.' S '.' { 7 * child }
SubstLMax ::= nat '.' SL '.' M '.' { 10 * child }
SubstLImax ::= nat '.' SL '.' I '.' { 10 * child }
SubstLParamNil ::= nat '.' SL '.' N '.' { 3 * child }
SubstLParamHit ::= nat '.' SL '.' H '.' { 7 * child }
SubstLParamMiss ::= nat '.' SL '.' M '.' { 10 * child }
ParamsDefinedManyBase ::= nat '.' PS '.' B '.' { 3 * child }
ParamsDefinedManyStep ::= nat '.' PS '.' S '.' { 7 * child }
SubstLManyBase ::= nat '.' SM '.' B '.' { 4 * child }
SubstLManyStep ::= nat '.' SM '.' S '.' { 10 * child }
FoldImaxsBase ::= nat '.' FI '.' B '.' { 3 * child }
FoldImaxsStep ::= nat '.' FI '.' S '.' { 7 * child }
EnsureImaxLeqBase ::= nat '.' EIL '.' B '.' { 29 * child }
LeqCoreZAny ::= nat '.' QC '.' ZA '.' { 5 * child }
LeqCoreAnyZ ::= nat '.' QC '.' AZ '.' { 5 * child }
LeqCoreParamParam ::= nat '.' QC '.' PP '.' { 7 * child }
LeqCoreParamZero ::= nat '.' QC '.' PZ '.' { 6 * child }
LeqCoreZeroParam ::= nat '.' QC '.' ZP '.' { 6 * child }
LeqCoreSuccAny ::= nat '.' QC '.' SA '.' { 8 * child }
LeqCoreAnySucc ::= nat '.' QC '.' AS '.' { 8 * child }
LeqCoreMaxAny ::= nat '.' QC '.' MA '.' { 11 * child }
LeqCoreParamMax ::= nat '.' QC '.' PM '.' { 12 * child }
LeqCoreZeroMax ::= nat '.' QC '.' ZM '.' { 11 * child }
LeqCoreImaxCongr ::= nat '.' QC '.' IC '.' { 7 * child }
LeqCoreImaxParamL ::= nat '.' QC '.' IL '.' { 9 * child }
LeqCoreImaxParamR ::= nat '.' QC '.' IR '.' { 9 * child }
LeqCoreImaxImaxAny ::= nat '.' QC '.' LI '.' { 10 * child }
LeqCoreImaxMaxAny ::= nat '.' QC '.' LM '.' { 12 * child }
LeqCoreAnyImaxImax ::= nat '.' QC '.' RI '.' { 10 * child }
LeqCoreAnyImaxMax ::= nat '.' QC '.' RM '.' { 12 * child }
LeqBase ::= nat '.' LE '.' B '.' { 8 * child }
EqAntisymmBase ::= nat '.' LQ '.' B '.' { 7 * child }
IsZeroBase ::= nat '.' IZ '.' B '.' { 3 * child }
IsNonzeroBase ::= nat '.' NZ '.' B '.' { 3 * child }
MaybeZeroBase ::= nat '.' MZ '.' B '.' { 3 * child }
MaybeNonzeroBase ::= nat '.' MN '.' B '.' { 3 * child }
EqAntisymmManyBase ::= nat '.' EM '.' T '.' { 3 * child }
EqAntisymmManyBaseFL ::= nat '.' EM '.' L '.' { 5 * child }
EqAntisymmManyBaseFR ::= nat '.' EM '.' R '.' { 5 * child }
EqAntisymmManyStep ::= nat '.' EM '.' S '.' { 11 * child }
InstNoBound ::= nat '.' I '.' N '.' { 3 * child }
InstByAux ::= nat '.' I '.' A '.' { 4 * child }
InstAuxNoBound ::= nat '.' IA '.' N '.' { 3 * child }
InstAuxVarHit ::= nat '.' IA '.' V '.' { 5 * child }
InstAuxVarMiss ::= nat '.' IA '.' M '.' { 4 * child }
InstAuxApp ::= nat '.' IA '.' A '.' { 10 * child }
InstAuxPi ::= nat '.' IA '.' P '.' { 12 * child }
InstAuxLambda ::= nat '.' IA '.' L '.' { 12 * child }
InstAuxLet ::= nat '.' IA '.' Z '.' { 15 * child }
AbstrNoLocals ::= nat '.' AB '.' N '.' { 2 * child }
AbstrByAux ::= nat '.' AB '.' A '.' { 4 * child }
AbstrAuxNoLocals ::= nat '.' AA '.' N '.' { 4 * child }
AbstrAuxLocalHit ::= nat '.' AA '.' X '.' { 10 * child }
AbstrAuxLocalMiss ::= nat '.' AA '.' M '.' { 8 * child }
AbstrAuxApp ::= nat '.' AA '.' A '.' { 10 * child }
AbstrAuxPi ::= nat '.' AA '.' P '.' { 10 * child }
AbstrAuxLambda ::= nat '.' AA '.' L '.' { 10 * child }
AbstrAuxLet ::= nat '.' AA '.' Z '.' { 13 * child }
SubstEVar ::= nat '.' SE '.' V '.' { 4 * child }
SubstESort ::= nat '.' SE '.' S '.' { 7 * child }
SubstEConst ::= nat '.' SE '.' C '.' { 8 * child }
SubstEApp ::= nat '.' SE '.' A '.' { 10 * child }
SubstEPi ::= nat '.' SE '.' P '.' { 12 * child }
SubstELambda ::= nat '.' SE '.' L '.' { 12 * child }
SubstELet ::= nat '.' SE '.' Z '.' { 15 * child }
SubstELocal ::= nat '.' SE '.' X '.' { 11 * child }
CalcHeightAuxVar ::= nat '.' CH '.' V '.' { 3 * child }
CalcHeightAuxSort ::= nat '.' CH '.' S '.' { 3 * child }
CalcHeightAuxConstHit ::= nat '.' CH '.' H '.' { 11 * child }
CalcHeightAuxConstMiss ::= nat '.' CH '.' M '.' { 4 * child }
CalcHeightAuxApp ::= nat '.' CH '.' A '.' { 8 * child }
CalcHeightAuxPi ::= nat '.' CH '.' P '.' { 10 * child }
CalcHeightAuxLambda ::= nat '.' CH '.' L '.' { 10 * child }
CalcHeightAuxLet ::= nat '.' CH '.' Z '.' { 13 * child }
HasIndOccVar ::= nat '.' IO '.' V '.' { 4 * child }
HasIndOccSort ::= nat '.' IO '.' S '.' { 4 * child }
HasIndOccConst ::= nat '.' IO '.' C '.' { 6 * child }
HasIndOccApp ::= nat '.' IO '.' A '.' { 9 * child }
HasIndOccPi ::= nat '.' IO '.' P '.' { 10 * child }
HasIndOccLambda ::= nat '.' IO '.' L '.' { 10 * child }
HasIndOccLet ::= nat '.' IO '.' Z '.' { 13 * child }
HasIndOccLocal ::= nat '.' IO '.' X '.' { 7 * child }
ApplyPiBase ::= nat '.' AP '.' B '.' { 10 * child }
ApplyLambdaBase ::= nat '.' AL '.' B '.' { 10 * child }
FoldPisNil ::= nat '.' FP '.' N '.' { 2 * child }
FoldPisCons ::= nat '.' FP '.' C '.' { 8 * child }
FoldLambdasNil ::= nat '.' FL '.' N '.' { 2 * child }
FoldLambdasCons ::= nat '.' FL '.' C '.' { 8 * child }
FoldlAppsNil ::= nat '.' FA '.' N '.' { 2 * child }
FoldlAppsCons ::= nat '.' FA '.' C '.' { 7 * child }
UnfoldAppsAuxBase ::= nat '.' UX '.' O '.' { 4 * child }
UnfoldAppsAuxApp ::= nat '.' UX '.' A '.' { 7 * child }
TelescopeSizePi ::= nat '.' TZ '.' P '.' { 7 * child }
TelescopeSizeOwise ::= nat '.' TZ '.' O '.' { 3 * child }
IsAppVar ::= nat '.' ISA '.' V '.' { 3 * child }
IsAppSort ::= nat '.' ISA '.' S '.' { 3 * child }
IsAppConst ::= nat '.' ISA '.' C '.' { 4 * child }
IsAppApp ::= nat '.' ISA '.' A '.' { 4 * child }
IsAppPi ::= nat '.' ISA '.' P '.' { 6 * child }
IsAppLambda ::= nat '.' ISA '.' L '.' { 6 * child }
IsAppLet ::= nat '.' ISA '.' Z '.' { 7 * child }
IsAppLocal ::= nat '.' ISA '.' X '.' { 6 * child }
IsPiVar ::= nat '.' ISP '.' V '.' { 3 * child }
IsPiSort ::= nat '.' ISP '.' S '.' { 3 * child }
IsPiConst ::= nat '.' ISP '.' C '.' { 4 * child }
IsPiApp ::= nat '.' ISP '.' A '.' { 4 * child }
IsPiPi ::= nat '.' ISP '.' P '.' { 6 * child }
IsPiLambda ::= nat '.' ISP '.' L '.' { 6 * child }
IsPiLet ::= nat '.' ISP '.' Z '.' { 7 * child }
IsPiLocal ::= nat '.' ISP '.' X '.' { 6 * child }
IsConstVar ::= nat '.' ISC '.' V '.' { 3 * child }
IsConstSort ::= nat '.' ISC '.' S '.' { 3 * child }
IsConstConst ::= nat '.' ISC '.' C '.' { 4 * child }
IsConstApp ::= nat '.' ISC '.' A '.' { 4 * child }
IsConstPi ::= nat '.' ISC '.' P '.' { 6 * child }
IsConstLambda ::= nat '.' ISC '.' L '.' { 6 * child }
IsConstLet ::= nat '.' ISC '.' Z '.' { 7 * child }
IsConstLocal ::= nat '.' ISC '.' X '.' { 6 * child }
IsLambdaVar ::= nat '.' ISL '.' V '.' { 3 * child }
IsLambdaSort ::= nat '.' ISL '.' S '.' { 3 * child }
IsLambdaConst ::= nat '.' ISL '.' C '.' { 4 * child }
IsLambdaApp ::= nat '.' ISL '.' A '.' { 4 * child }
IsLambdaPi ::= nat '.' ISL '.' P '.' { 6 * child }
IsLambdaLambda ::= nat '.' ISL '.' L '.' { 6 * child }
IsLambdaLet ::= nat '.' ISL '.' Z '.' { 7 * child }
IsLambdaLocal ::= nat '.' ISL '.' X '.' { 6 * child }
WhnfSortBase ::= nat '.' WS '.' B '.' { 5 * child }
WhnfLambdaNotLambda ::= nat '.' WL '.' X '.' { 10 * child }
WhnfLambdaNoArgs ::= nat '.' WL '.' N '.' { 7 * child }
WhnfLambdaStep ::= nat '.' WL '.' S '.' { 12 * child }
WhnfLetBase ::= nat '.' WZ '.' B '.' { 13 * child }
ReduceQuotLiftBase ::= nat '.' QL '.' B '.' { 19 * child }
ReduceQuotIndBase ::= nat '.' QI '.' B '.' { 19 * child }
MkNullaryCtorBase ::= nat '.' NC '.' B '.' { 19 * child }
ToCtorWhenKSkip ::= nat '.' WK '.' S '.' { 2 * child }
ToCtorWhenKBase ::= nat '.' WK '.' B '.' { 26 * child }
GetRecRuleBase ::= nat '.' RR '.' B '.' { 6 * child }
GetRecRuleStep ::= nat '.' RR '.' S '.' { 9 * child }
ReduceIndRecBase ::= nat '.' RI '.' B '.' { 47 * child }
WhnfCoreSort ::= nat '.' WC '.' S '.' { 5 * child }
WhnfCoreLambda ::= nat '.' WC '.' L '.' { 6 * child }
WhnfCoreLet ::= nat '.' WC '.' Z '.' { 6 * child }
WhnfCoreReduceQuotLift ::= nat '.' WC '.' I '.' { 3 * child }
WhnfCoreReduceQuotInd ::= nat '.' WC '.' N '.' { 3 * child }
WhnfCoreReduceIndRec ::= nat '.' WC '.' R '.' { 3 * child }
WhnfCoreOwise ::= nat '.' WC '.' O '.' { 1 * child }
WhnfCoreOnly ::= nat '.' WH '.' O '.' { 3 * child }
WhnfUnfolding ::= nat '.' WH '.' U '.' { 7 * child }
UnfoldDefBase ::= nat '.' UD '.' B '.' { 15 * child }
IsSortZeroBase ::= nat '.' SZ '.' B '.' { 3 * child }
IsPropositionBase ::= nat '.' PR '.' B '.' { 4 * child }
IsProofBase ::= nat '.' PF '.' B '.' { 4 * child }
ProofIrrelEqBase ::= nat '.' IR '.' B '.' { 8 * child }
LazyDeltaStepRefl ::= nat '.' LD '.' R '.' { 3 * child }
LazyDeltaStepSort ::= nat '.' LD '.' S '.' { 4 * child }
LazyDeltaStepPi ::= nat '.' LD '.' P '.' { 4 * child }
LazyDeltaStepLambda ::= nat '.' LD '.' L '.' { 4 * child }
LazyDeltaStepNoneNone ::= nat '.' LD '.' NN '.' { 3 * child }
LazyDeltaStepUnfoldingLeft ::= nat '.' LD '.' UL '.' { 8 * child }
LazyDeltaStepUnfoldingRight ::= nat '.' LD '.' UR '.' { 8 * child }
LazyDeltaStepExtensional ::= nat '.' LD '.' E '.' { 14 * child }
LazyDeltaStepUnfoldingBoth ::= nat '.' LD '.' UB '.' { 12 * child }
DefEqPtrEq ::= nat '.' EQ '.' R '.' { 3 * child }
DefEqSort ::= nat '.' EQ '.' S '.' { 8 * child }
DefEqPi ::= nat '.' EQ '.' P '.' { 8 * child }
DefEqLambda ::= nat '.' EQ '.' P '.' { 8 * child }
DefEqProofIrrelEq ::= nat '.' EQ '.' I '.' { 8 * child }
DefEqDeltaShort ::= nat '.' EQ '.' D '.' { 8 * child }
DefEqConst ::= nat '.' EQ '.' C '.' { 11 * child }
DefEqLocal ::= nat '.' EQ '.' X '.' { 11 * child }
DefEqApp ::= nat '.' EQ '.' A '.' { 11 * child }
DefEqEtaLr ::= nat '.' EQ '.' U '.' { 11 * child }
DefEqEtaRl ::= nat '.' EQ '.' V '.' { 11 * child }
DefEqSortBase ::= nat '.' ES '.' B '.' { 6 * child }
DefEqLambdaBase ::= nat '.' EL '.' B '.' { 9 * child }
DefEqLambdaStep ::= nat '.' EL '.' E '.' { 21 * child }
DefEqPiBase ::= nat '.' EP '.' B '.' { 9 * child }
DefEqPiStep ::= nat '.' EP '.' E '.' { 21 * child }
ArgsEqAuxBase ::= nat '.' FX '.' B '.' { 3 * child }
ArgsEqAuxStep ::= nat '.' FX '.' S '.' { 9 * child }
DefEqConstBase ::= nat '.' EC '.' B '.' { 8 * child }
DefEqLocalBase ::= nat '.' EX '.' B '.' { 10 * child }
DefEqAppBase ::= nat '.' EA '.' B '.' { 11 * child }
DefEqEtaBase ::= nat '.' ET '.' B '.' { 17 * child }
EnsureSortBase ::= nat '.' ENS '.' B '.' { 2 * child }
EnsureSortReduce ::= nat '.' ENS '.' R '.' { 4 * child }
EnsureTypeBase ::= nat '.' ENT '.' B '.' { 5 * child }
EnsurePiBase ::= nat '.' ENP '.' B '.' { 2 * child }
EnsurePiReduce ::= nat '.' ENP '.' R '.' { 4 * child }
InferSort ::= nat '.' IN '.' S '.' { 4 * child }
InferConst ::= nat '.' IN '.' C '.' { 4 * child }
InferApp ::= nat '.' IN '.' A '.' { 8 * child }
InferPi ::= nat '.' IN '.' P '.' { 4 * child }
InferLambda ::= nat '.' IN '.' L '.' { 4 * child }
InferLet ::= nat '.' IN '.' Z '.' { 4 * child }
InferLocal ::= nat '.' IN '.' X '.' { 4 * child }
InferSortInferOnly ::= nat '.' IS '.' I '.' { 3 * child }
InferSortChecked ::= nat '.' IS '.' C '.' { 4 * child }
InferConstInferOnly ::= nat '.' IC '.' I '.' { 11 * child }
InferConstChecked ::= nat '.' IC '.' C '.' { 13 * child }
InferAppBase ::= nat '.' INA '.' B '.' { 6 * child }
InferAppStepPiInferOnly ::= nat '.' INA '.' PI '.' { 12 * child }
InferAppStepPiChecked ::= nat '.' INA '.' PC '.' { 17 * child }
InferAppStepNotPi ::= nat '.' INA '.' SN '.' { 14 * child }
InferSortOfBase ::= nat '.' ISO '.' B '.' { 6 * child }
InferPiBase ::= nat '.' NP '.' B '.' { 12 * child }
InferPiStep ::= nat '.' NP '.' S '.' { 18 * child }
FoldPisOnceBase ::= nat '.' FO '.' B '.' { 3 * child }
FoldPisOnceStep ::= nat '.' FO '.' S '.' { 14 * child }
InferLambdaBase ::= nat '.' IL '.' B '.' { 13 * child }
InferLambdaStepInferOnly ::= nat '.' IL '.' I '.' { 15 * child }
InferLambdaStepChecked ::= nat '.' IL '.' C '.' { 17 * child }
InferLetInferOnly ::= nat '.' INZ '.' I '.' { 11 * child }
InferLetChecked ::= nat '.' INZ '.' C '.' { 16 * child }
InferLocalBase ::= nat '.' IX '.' B '.' { 4 * child }
MkLocalParamsBase ::= nat '.' LPS '.' B '.' { 3 * child }
MkLocalParamsStep ::= nat '.' LPS '.' S '.' { 14 * child }
HandleTelescope1Base ::= nat '.' HT '.' B '.' { 9 * child }
HandleTelescope1StepIndex ::= nat '.' HT '.' I '.' { 18 * child }
HandleTelescope1StepParam ::= nat '.' HT '.' P '.' { 18 * child }
HandleTelescopesBase ::= nat '.' HTS '.' B '.' { 12 * child }
HandleTelescopesStep ::= nat '.' HTS '.' I '.' { 22 * child }
CheckIndTypesBase ::= nat '.' CI '.' B '.' { 10 * child }
MkIndTypesBase ::= nat '.' MIT '.' B '.' { 5 * child }
MkIndTypesStep ::= nat '.' MIT '.' S '.' { 14 * child }
ValidParamAppsBase ::= nat '.' VP '.' B '.' { 3 * child }
ValidParamAppsStep ::= nat '.' VP '.' S '.' { 7 * child }
IsValidIndAppBaseFf ::= nat '.' VA '.' F '.' { 13 * child }
IsValidIndAppBaseTt ::= nat '.' VA '.' T '.' { 15 * child }
WhichValidIndAppBase ::= nat '.' WV '.' B '.' { 10 * child }
WhichValidIndAppStep ::= nat '.' WV '.' S '.' { 12 * child }
IsRecArgumentBase ::= nat '.' IRA '.' B '.' { 8 * child }
IsRecArgumentStep ::= nat '.' IRA '.' S '.' { 16 * child }
CheckPositivity1ByUnsafe ::= nat '.' CKP '.' U '.' { 4 * child }
CheckPositivity1NoIndOccs ::= nat '.' CKP '.' N '.' { 7 * child }
CheckPositivity1BaseValid ::= nat '.' CKP '.' V '.' { 7 * child }
CheckPositivity1Step ::= nat '.' CKP '.' S '.' { 16 * child }
CheckCtor1Base ::= nat '.' CC '.' B '.' { 6 * child }
CheckCtor1StepProp ::= nat '.' CC '.' Z '.' { 18 * child }
CheckCtor1StepLe ::= nat '.' CC '.' L '.' { 18 * child }
CheckCtor1StepParam ::= nat '.' CC '.' P '.' { 19 * child }
MkCtorGroup1Base ::= nat '.' MCG '.' B '.' { 7 * child }
MkCtorGroup1Step ::= nat '.' MCG '.' S '.' { 18 * child }
MkCtorsBase ::= nat '.' MCS '.' B '.' { 7 * child }
MkCtorsStep ::= nat '.' MCS '.' S '.' { 21 * child }
DeclareCtorsBase ::= nat '.' DCS '.' B '.' { 1 * child }
LargeElimTestAuxBase ::= nat '.' LEA '.' B '.' { 9 * child }
LargeElimTestAuxStepZero ::= nat '.' LEA '.' Z '.' { 16 * child }
LargeElimTestAuxStepNonzero ::= nat '.' LEA '.' N '.' { 16 * child }
LargeElimTestAuxStepParam ::= nat '.' LEA '.' P '.' { 14 * child }
LargeElimTestNonzero ::= nat '.' LET '.' N '.' { 3 * child }
LargeElimTestIsMutual ::= nat '.' LET '.' M '.' { 3 * child }
LargeElimTestManyCtors ::= nat '.' LET '.' C '.' { 3 * child }
LargeElimTestNoCtors ::= nat '.' LET '.' X '.' { 2 * child }
LargeElimTestByAux ::= nat '.' LET '.' A '.' { 5 * child }
MkElimLevelLarge ::= nat '.' ME '.' L '.' { 4 * child }
MkElimLevelSmall ::= nat '.' ME '.' S '.' { 3 * child }
InitKTargetAuxBase ::= nat '.' KTA '.' B '.' { 5 * child }
InitKTargetAuxStep ::= nat '.' KTA '.' S '.' { 9 * child }
InitKTargetIsMutual ::= nat '.' KT '.' M '.' { 2 * child }
InitKTargetNonzero ::= nat '.' KT '.' N '.' { 3 * child }
InitKTargetNotOneCtor ::= nat '.' KT '.' O '.' { 2 * child }
InitKTargetByAux ::= nat '.' KT '.' A '.' { 4 * child }
MkMajorsAuxBase ::= nat '.' MJA '.' B '.' { 4 * child }
MkMajorsAuxStep ::= nat '.' MJA '.' S '.' { 18 * child }
MkMotiveIndep ::= nat '.' MKC '.' I '.' { 11 * child }
MkMotiveDep ::= nat '.' MKC '.' D '.' { 13 * child }
MkMotivesBase ::= nat '.' MCZ '.' B '.' { 5 * child }
MkMotivesStep ::= nat '.' MCZ '.' S '.' { 14 * child }
SepRecCtorArgsBase ::= nat '.' SCA '.' B '.' { 9 * child }
SepRecCtorArgsNonrecArg ::= nat '.' SCA '.' N '.' { 20 * child }
SepRecCtorArgsRecArg ::= nat '.' SCA '.' R '.' { 21 * child }
SepRecCtorArgsParam ::= nat '.' SCA '.' P '.' { 18 * child }
GetIIndicesBase ::= nat '.' GI '.' B '.' { 9 * child }
HandleRecArgsAuxBase ::= nat '.' HRX '.' B '.' { 3 * child }
HandleRecArgsAuxStep ::= nat '.' HRX '.' S '.' { 16 * child }
HandleRecArgsMinorBase ::= nat '.' RAM '.' B '.' { 3 * child }
HandleRecArgsMinorStepIndep ::= nat '.' RAM '.' I '.' { 28 * child }
HandleRecArgsMinorStepDep ::= nat '.' RAM '.' D '.' { 31 * child }
MkMinorsGroupBase ::= nat '.' MMG '.' B '.' { 9 * child }
MkMinorsGroupStepIndep ::= nat '.' MMG '.' I '.' { 35 * child }
MkMinorsGroupStepDep ::= nat '.' MMG '.' D '.' { 41 * child }
MkMinorsAuxBase ::= nat '.' MMX '.' B '.' { 8 * child }
MkMinorsAuxStep ::= nat '.' MMX '.' S '.' { 22 * child }
MkMinorsBase ::= nat '.' MMS '.' B '.' { 4 * child }
GetRecLevelsParam ::= nat '.' GRL '.' P '.' { 5 * child }
GetRecLevelsNotParam ::= nat '.' GRL '.' N '.' { 4 * child }
HandleRecArgsRuleBase ::= nat '.' RAR '.' B '.' { 4 * child }
HandleRecArgsRuleStep ::= nat '.' RAR '.' S '.' { 38 * child }
MkRecRule1Base ::= nat '.' MRO '.' B '.' { 31 * child }
MkRecRulesGroupBase ::= nat '.' MRG '.' B '.' { 10 * child }
MkRecRulesGroupStep ::= nat '.' MRG '.' S '.' { 20 * child }
MkRecRulesBase ::= nat '.' MRR '.' B '.' { 9 * child }
MkRecRulesStep ::= nat '.' MRR '.' S '.' { 25 * child }
MkRecursorAuxBaseIndep ::= nat '.' MRA '.' I '.' { 29 * child }
MkRecursorAuxBaseDep ::= nat '.' MRA '.' D '.' { 30 * child }
MkRecursorsBase ::= nat '.' MR '.' B '.' { 11 * child }
MkRecursorsStep ::= nat '.' MR '.' S '.' { 28 * child }
CheckVitalsBase ::= nat '.' CV '.' B '.' { 6 * child }
GetDeclarViewAxiom ::= nat '.' GV '.' A '.' { 1 * child }
GetDeclarViewDefinition ::= nat '.' GV '.' D '.' { 1 * child }
GetDeclarViewTheorem ::= nat '.' GV '.' T '.' { 1 * child }
GetDeclarViewOpaque ::= nat '.' GV '.' O '.' { 1 * child }
GetDeclarViewQuot ::= nat '.' GV '.' Q '.' { 1 * child }
GetDeclarViewInductive ::= nat '.' GV '.' I '.' { 1 * child }
GetDeclarViewConstructor ::= nat '.' GV '.' C '.' { 1 * child }
GetDeclarViewRecursor ::= nat '.' GV '.' R '.' { 1 * child }
AdmitDeclarUnchecked ::= nat '.' AD '.' U '.' { 1 * child }
AdmitDeclarAxiom ::= nat '.' AD '.' A '.' { 7 * child }
AdmitDeclarSafeDef ::= nat '.' AD '.' D '.' { 12 * child }
AdmitDeclarTheorem ::= nat '.' AD '.' T '.' { 10 * child }
AdmitDeclarOpaque ::= nat '.' AD '.' O '.' { 11 * child }
AdmitDeclarQuot ::= nat '.' AD '.' Q '.' { 5 * child }
AdmitDeclarInductives ::= nat '.' AD '.' I '.' { 14 * child }
AdmitDeclarConstructors ::= nat '.' AD '.' C '.' { 4 * child }
AdmitDeclarRecursors ::= nat '.' AD '.' R '.' { 17 * child }
